<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Dash</title>
    <style>
        /* RESET ET STYLES DE BASE */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* GRILLE D'ARRIÈRE-PLAN ANIMÉE */
        .grid-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: -1;
            animation: gridMove 60s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(20px, 20px); }
        }

        /* ÉCRAN PRINCIPAL */
        #main-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        /* TITRE ANIMÉ */
        .title {
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-shadow: 3px 3px 0 #000, 5px 5px 0 rgba(0, 0, 0, 0.2);
            animation: bounce 1.5s ease infinite;
        }

        .title span {
            display: inline-block;
        }

        .title span:nth-child(1) { color: #FF5252; }
        .title span:nth-child(2) { color: #FFD740; }
        .title span:nth-child(3) { color: #7C4DFF; }
        .title span:nth-child(4) { color: #18FFFF; }
        .title span:nth-child(5) { color: #69F0AE; }
        .title span:nth-child(6) { color: #FF4081; }
        .title span:nth-child(7) { color: #FF5252; }
        .title span:nth-child(8) { color: #FFD740; }
        .title span:nth-child(9) { color: #7C4DFF; }
        .title span:nth-child(10) { color: #18FFFF; }

        @keyframes bounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.05); }
        }

        /* BOUTONS */
        .btn {
            background: linear-gradient(145deg, #6a11cb, #2575fc);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 15px 30px;
            margin: 10px 0;
            font-size: 1.2rem;
            font-weight: bold;
            width: 200px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 0 3px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .btn:hover::after {
            transform: translateX(0);
        }

        /* BOUTON MUTE */
        .mute-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .mute-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        /* ÉCRAN DE JEU */
        #game-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 10px;
        }

        /* CONTENEUR PRINCIPAL DU JEU */
        .game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
        }

        /* INFORMATIONS DU JEU */
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            width: 100%;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 12px;
            border-radius: 10px;
            min-width: 80px;
            text-align: center;
        }

        .info-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* CONTENEUR DU PLATEAU ET DE L'UI LATERALE */
        .game-area {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        /* ZONE DE JEU PRINCIPALE */
        .game-board {
            position: relative;
            width: 250px;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* UI LATERALE */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100px;
        }

        .next-piece, .hold-piece {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }

        .panel-label {
            font-size: 0.9rem;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .next-canvas, .hold-canvas {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        /* CONTROLES TACTILES */
        .touch-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            width: 100%;
            max-width: 500px;
            padding: 0 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .movement-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .horizontal-controls {
            display: flex;
            gap: 10px;
        }

        /* OVERLAY DE PAUSE ET GAME OVER */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .overlay h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
        }

        .overlay-content {
            background: rgba(30, 30, 60, 0.9);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
        }

        .stats {
            margin: 20px 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
        }

        /* ÉCRAN DE SELECTION DE MODE */
        #mode-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        .mode-title {
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .mode-btn {
            width: 250px;
            margin: 15px 0;
        }

        /* ÉCRAN DES SCORES */
        #scores-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        .scores-title {
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .scores-list {
            width: 100%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .score-item:last-child {
            border-bottom: none;
        }

        /* ÉCRAN DES COMMANDES */
        #controls-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        .controls-title {
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .control-instruction {
            display: flex;
            align-items: center;
            margin: 15px 0;
            width: 100%;
            max-width: 400px;
        }

        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            min-width: 80px;
            text-align: center;
            margin-right: 20px;
            font-weight: bold;
        }

        /* ÉCRAN DES CREDITS */
        #credits-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        .credits-title {
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .credits-content {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            line-height: 1.6;
        }

        /* MEDIA QUERIES POUR LA RESPONSIVITE */
        @media (max-height: 700px) {
            .title {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }
            
            .btn {
                padding: 12px 25px;
                font-size: 1rem;
                width: 180px;
            }
            
            .game-board {
                width: 200px;
                height: 400px;
            }
            
            .side-panel {
                width: 80px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
            }
        }

        @media (max-width: 400px) {
            .title {
                font-size: 2rem;
            }
            
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .side-panel {
                flex-direction: row;
                width: 100%;
                justify-content: space-around;
                margin-top: 10px;
            }
            
            .touch-controls {
                flex-wrap: wrap;
            }
            
            .control-group {
                flex-direction: row;
            }
        }
    </style>
</head>
<body>
    <div class="grid-bg"></div>
    
    <!-- ÉCRAN PRINCIPAL -->
    <div id="main-screen">
        <h1 class="title">
            <span>B</span><span>L</span><span>O</span><span>C</span><span>K</span>
            <span>D</span><span>A</span><span>S</span><span>H</span>
        </h1>
        
        <button class="btn" id="play-btn">Jouer</button>
        <button class="btn" id="modes-btn">Modes</button>
        <button class="btn" id="controls-btn">Commandes</button>
        <button class="btn" id="scores-btn">Classement</button>
        <button class="btn" id="credits-btn">Crédits</button>
    </div>
    
    <!-- ÉCRAN DE SELECTION DE MODE -->
    <div id="mode-screen">
        <h2 class="mode-title">Choisissez un mode</h2>
        
        <button class="btn mode-btn" data-mode="easy">Facile</button>
        <button class="btn mode-btn" data-mode="normal">Normal</button>
        <button class="btn mode-btn" data-mode="hard">Difficile</button>
        <button class="btn mode-btn" data-mode="expert">Expert</button>
        
        <button class="btn" id="back-from-modes" style="margin-top: 30px;">Retour</button>
    </div>
    
    <!-- ÉCRAN DE JEU -->
    <div id="game-screen">
        <div class="game-info">
            <div class="info-box">
                <div class="info-label">SCORE</div>
                <div class="info-value" id="score">0</div>
            </div>
            <div class="info-box">
                <div class="info-label">LIGNES</div>
                <div class="info-value" id="lines">0</div>
            </div>
            <div class="info-box">
                <div class="info-label">NIVEAU</div>
                <div class="info-value" id="level">1</div>
            </div>
        </div>
        
        <div class="game-area">
            <div class="side-panel">
                <div class="hold-piece">
                    <div class="panel-label">HOLD</div>
                    <canvas id="hold-canvas" class="hold-canvas" width="80" height="80"></canvas>
                </div>
            </div>
            
            <div class="game-board">
                <canvas id="board" width="250" height="500"></canvas>
            </div>
            
            <div class="side-panel">
                <div class="next-piece">
                    <div class="panel-label">SUIVANT</div>
                    <canvas id="next-canvas" class="next-canvas" width="80" height="80"></canvas>
                </div>
            </div>
        </div>
        
        <div class="touch-controls">
            <div class="control-group">
                <div class="control-btn" id="rotate-btn">↻</div>
            </div>
            
            <div class="movement-controls">
                <div class="horizontal-controls">
                    <div class="control-btn" id="left-btn">←</div>
                    <div class="control-btn" id="right-btn">→</div>
                </div>
                <div class="control-btn" id="down-btn">↓</div>
            </div>
            
            <div class="control-group">
                <div class="control-btn" id="drop-btn">⤓</div>
            </div>
        </div>
        
        <!-- OVERLAY DE PAUSE -->
        <div id="pause-overlay" class="overlay">
            <div class="overlay-content">
                <h2>PAUSE</h2>
                <button class="btn" id="resume-btn">Reprendre</button>
                <button class="btn" id="restart-btn">Recommencer</button>
                <button class="btn" id="menu-btn">Menu</button>
            </div>
        </div>
        
        <!-- OVERLAY DE GAME OVER -->
        <div id="gameover-overlay" class="overlay">
            <div class="overlay-content">
                <h2>GAME OVER</h2>
                
                <div class="stats">
                    <div class="stat">
                        <div class="info-label">SCORE FINAL</div>
                        <div class="info-value" id="final-score">0</div>
                    </div>
                    <div class="stat">
                        <div class="info-label">LIGNES</div>
                        <div class="info-value" id="final-lines">0</div>
                    </div>
                    <div class="stat">
                        <div class="info-label">NIVEAU</div>
                        <div class="info-value" id="final-level">1</div>
                    </div>
                    <div class="stat">
                        <div class="info-label">MODE</div>
                        <div class="info-value" id="final-mode">Normal</div>
                    </div>
                </div>
                
                <button class="btn" id="replay-btn">Rejouer</button>
                <button class="btn" id="save-score-btn">Sauver le score</button>
                <button class="btn" id="gameover-menu-btn">Menu</button>
            </div>
        </div>
    </div>
    
    <!-- ÉCRAN DES SCORES -->
    <div id="scores-screen">
        <h2 class="scores-title">Meilleurs Scores</h2>
        
        <div class="scores-list" id="scores-list">
            <!-- Les scores seront ajoutés dynamiquement -->
        </div>
        
        <button class="btn" id="back-from-scores">Retour</button>
    </div>
    
    <!-- ÉCRAN DES COMMANDES -->
    <div id="controls-screen">
        <h2 class="controls-title">Commandes</h2>
        
        <div class="control-instruction">
            <div class="control-key">← →</div>
            <div>Déplacer gauche/droite</div>
        </div>
        
        <div class="control-instruction">
            <div class="control-key">↓</div>
            <div>Descente rapide</div>
        </div>
        
        <div class="control-instruction">
            <div class="control-key">Z / ↑</div>
            <div>Rotation</div>
        </div>
        
        <div class="control-instruction">
            <div class="control-key">Espace</div>
            <div>Chute instantanée</div>
        </div>
        
        <div class="control-instruction">
            <div class="control-key">P</div>
            <div>Pause</div>
        </div>
        
        <div class="control-instruction">
            <div class="control-key">M</div>
            <div>Activer/désactiver le son</div>
        </div>
        
        <button class="btn" id="back-from-controls" style="margin-top: 30px;">Retour</button>
    </div>
    
    <!-- ÉCRAN DES CREDITS -->
    <div id="credits-screen">
        <h2 class="credits-title">Crédits</h2>
        
        <div class="credits-content">
            <p><strong>Block Dash</strong></p>
            <p>Développé par zznkch</p>
            <p>Musique de style "Korobeiniki" (domaine public)</p>
            <p>SFX originaux</p>
            <p>© 2025 Tous droits réservés</p>
        </div>
        
        <button class="btn" id="back-from-credits" style="margin-top: 30px;">Retour</button>
    </div>
    
    <!-- BOUTON MUTE -->
    <button class="mute-btn" id="mute-btn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M14.016 3.234Q16.125 3.234 17.625 4.734T19.125 8.484V15.516Q19.125 17.766 17.625 19.266T14.016 20.766H9.984Q7.734 20.766 6.234 19.266T4.734 15.516V8.484Q4.734 6.234 6.234 4.734T9.984 3.234H14.016Z"/>
        </svg>
    </button>
    
    <script>
        // CONSTANTES ET CONFIGURATION DU JEU
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 25;
        const COLORS = [
            null,
            '#FF0D72', // I - Rose
            '#0DC2FF', // J - Bleu
            '#0DFF72', // L - Vert
            '#F538FF', // O - Violet
            '#FF8E0D', // S - Orange
            '#FFE138', // T - Jaune
            '#3877FF'  // Z - Bleu foncé
        ];

        // Définition des pièces Tetrominos avec leurs rotations
        const PIECES = {
            I: {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                color: 1
            },
            J: {
                shape: [
                    [2, 0, 0],
                    [2, 2, 2],
                    [0, 0, 0]
                ],
                color: 2
            },
            L: {
                shape: [
                    [0, 0, 3],
                    [3, 3, 3],
                    [0, 0, 0]
                ],
                color: 3
            },
            O: {
                shape: [
                    [0, 4, 4],
                    [0, 4, 4],
                    [0, 0, 0]
                ],
                color: 4
            },
            S: {
                shape: [
                    [0, 5, 5],
                    [5, 5, 0],
                    [0, 0, 0]
                ],
                color: 5
            },
            T: {
                shape: [
                    [0, 6, 0],
                    [6, 6, 6],
                    [0, 0, 0]
                ],
                color: 6
            },
            Z: {
                shape: [
                    [7, 7, 0],
                    [0, 7, 7],
                    [0, 0, 0]
                ],
                color: 7
            }
        };

        // Configuration des modes de difficulté
        const MODES = {
            easy: { gravity: 800, lockDelay: 600, acceleration: 0.92, name: "Facile" },
            normal: { gravity: 600, lockDelay: 500, acceleration: 0.9, name: "Normal" },
            hard: { gravity: 400, lockDelay: 400, acceleration: 0.88, name: "Difficile" },
            expert: { gravity: 250, lockDelay: 300, acceleration: 0.85, name: "Expert" }
        };

        // ÉLÉMENTS DOM
        const mainScreen = document.getElementById('main-screen');
        const modeScreen = document.getElementById('mode-screen');
        const gameScreen = document.getElementById('game-screen');
        const scoresScreen = document.getElementById('scores-screen');
        const controlsScreen = document.getElementById('controls-screen');
        const creditsScreen = document.getElementById('credits-screen');
        
        const boardCanvas = document.getElementById('board');
        const nextCanvas = document.getElementById('next-canvas');
        const holdCanvas = document.getElementById('hold-canvas');
        
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');
        
        const pauseOverlay = document.getElementById('pause-overlay');
        const gameoverOverlay = document.getElementById('gameover-overlay');
        
        const finalScoreElement = document.getElementById('final-score');
        const finalLinesElement = document.getElementById('final-lines');
        finalLevelElement = document.getElementById('final-level');
        finalModeElement = document.getElementById('final-mode');
        
        const muteBtn = document.getElementById('mute-btn');
        
        // CONTEXTES CANVAS
        const ctx = boardCanvas.getContext('2d');
        const nextCtx = nextCanvas.getContext('2d');
        const holdCtx = holdCanvas.getContext('2d');
        
        // ÉTAT DU JEU
        let board = createBoard();
        let piece = null;
        let nextPiece = null;
        let holdPiece = null;
        let canHold = true;
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameMode = MODES.normal;
        let gameOver = false;
        let paused = false;
        let lastTime = 0;
        let dropCounter = 0;
        let dropInterval = gameMode.gravity;
        let lockDelayCounter = 0;
        let audioEnabled = true;
        let moveDownPressed = false;
        let moveLeftPressed = false;
        let moveRightPressed = false;
        let audioContext = null;
        
        // INITIALISATION DES ÉVÉNEMENTS
        function initEvents() {
            // Événements des boutons du menu principal
            document.getElementById('play-btn').addEventListener('click', () => showScreen(modeScreen));
            document.getElementById('modes-btn').addEventListener('click', () => showScreen(modeScreen));
            document.getElementById('controls-btn').addEventListener('click', () => showScreen(controlsScreen));
            document.getElementById('scores-btn').addEventListener('click', () => {
                showScores();
                showScreen(scoresScreen);
            });
            document.getElementById('credits-btn').addEventListener('click', () => showScreen(creditsScreen));
            
            // Événements des boutons de retour
            document.getElementById('back-from-modes').addEventListener('click', () => showScreen(mainScreen));
            document.getElementById('back-from-scores').addEventListener('click', () => showScreen(mainScreen));
            document.getElementById('back-from-controls').addEventListener('click', () => showScreen(mainScreen));
            document.getElementById('back-from-credits').addEventListener('click', () => showScreen(mainScreen));
            
            // Événements des boutons de mode
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.getAttribute('data-mode');
                    startGame(mode);
                });
            });
            
            // Événements des contrôles tactiles
            document.getElementById('left-btn').addEventListener('touchstart', () => {
                moveLeftPressed = true;
                movePiece(-1);
            });
            document.getElementById('left-btn').addEventListener('touchend', () => {
                moveLeftPressed = false;
            });
            
            document.getElementById('right-btn').addEventListener('touchstart', () => {
                moveRightPressed = true;
                movePiece(1);
            });
            document.getElementById('right-btn').addEventListener('touchend', () => {
                moveRightPressed = false;
            });
            
            document.getElementById('down-btn').addEventListener('touchstart', () => {
                moveDownPressed = true;
            });
            document.getElementById('down-btn').addEventListener('touchend', () => {
                moveDownPressed = false;
            });
            
            document.getElementById('rotate-btn').addEventListener('click', rotate);
            document.getElementById('drop-btn').addEventListener('click', hardDrop);
            
            // Événements du clavier
            document.addEventListener('keydown', event => {
                if (gameOver || paused) return;
                
                switch (event.keyCode) {
                    case 37: // Flèche gauche
                        event.preventDefault();
                        movePiece(-1);
                        break;
                    case 39: // Flèche droite
                        event.preventDefault();
                        movePiece(1);
                        break;
                    case 40: // Flèche bas
                        event.preventDefault();
                        moveDownPressed = true;
                        break;
                    case 38: // Flèche haut
                    case 90: // Z
                        event.preventDefault();
                        rotate();
                        break;
                    case 32: // Espace
                        event.preventDefault();
                        hardDrop();
                        break;
                    case 80: // P
                        event.preventDefault();
                        togglePause();
                        break;
                }
            });
            
            document.addEventListener('keyup', event => {
                if (event.keyCode === 40) { // Flèche bas
                    moveDownPressed = false;
                }
            });
            
            // Événements des boutons de pause/jeu terminé
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('restart-btn').addEventListener('click', () => startGame(gameMode));
            document.getElementById('menu-btn').addEventListener('click', () => showScreen(mainScreen));
            document.getElementById('replay-btn').addEventListener('click', () => startGame(gameMode));
            document.getElementById('save-score-btn').addEventListener('click', saveScore);
            document.getElementById('gameover-menu-btn').addEventListener('click', () => showScreen(mainScreen));
            
            // Événement du bouton mute
            const storedMute = localStorage.getItem('blockDashMute');
            audioEnabled = storedMute !== 'true';
            updateMuteButton();
            
            muteBtn.addEventListener('click', () => {
                audioEnabled = !audioEnabled;
                localStorage.setItem('blockDashMute', !audioEnabled);
                updateMuteButton();
            });
            
            // Gestes tactiles pour le plateau de jeu
            let touchStartX = 0;
            let touchStartY = 0;
            
            boardCanvas.addEventListener('touchstart', event => {
                if (gameOver || paused) return;
                
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                event.preventDefault();
            }, { passive: false });
            
            boardCanvas.addEventListener('touchmove', event => {
                event.preventDefault();
            }, { passive: false });
            
            boardCanvas.addEventListener('touchend', event => {
                if (gameOver || paused) return;
                
                const touchEndX = event.changedTouches[0].clientX;
                const touchEndY = event.changedTouches[0].clientY;
                
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // Seuil pour détecter un swipe
                const threshold = 30;
                
                if (Math.abs(diffX) > threshold || Math.abs(diffY) > threshold) {
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        // Mouvement horizontal
                        if (diffX > 0) {
                            movePiece(1);
                        } else {
                            movePiece(-1);
                        }
                    } else {
                        // Mouvement vertical
                        if (diffY > 0) {
                            // Swipe vers le bas - descente rapide
                            moveDownPressed = true;
                        } else {
                            // Swipe vers le haut - rotation
                            rotate();
                        }
                    }
                } else {
                    // Tap simple - rotation
                    rotate();
                }
                
                event.preventDefault();
            }, { passive: false });
            
            // Tap long pour le drop instantané
            let longPressTimer;
            
            boardCanvas.addEventListener('touchstart', event => {
                if (gameOver || paused) return;
                
                longPressTimer = setTimeout(() => {
                    hardDrop();
                }, 500);
                
                event.preventDefault();
            }, { passive: false });
            
            boardCanvas.addEventListener('touchend', event => {
                clearTimeout(longPressTimer);
                event.preventDefault();
            }, { passive: false });
        }
        
        // FONCTIONS D'AFFICHAGE
        function showScreen(screen) {
            // Cacher tous les écrans
            mainScreen.style.display = 'none';
            modeScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            scoresScreen.style.display = 'none';
            controlsScreen.style.display = 'none';
            creditsScreen.style.display = 'none';
            
            // Afficher l'écran demandé
            screen.style.display = 'flex';
        }
        
        function updateMuteButton() {
            const icon = muteBtn.querySelector('svg path');
            if (audioEnabled) {
                icon.setAttribute('d', 'M14.016 3.234Q16.125 3.234 17.625 4.734T19.125 8.484V15.516Q19.125 17.766 17.625 19.266T14.016 20.766H9.984Q7.734 20.766 6.234 19.266T4.734 15.516V8.484Q4.734 6.234 6.234 4.734T9.984 3.234H14.016Z');
            } else {
                icon.setAttribute('d', 'M13.5 17.625Q12.375 17.625 11.625 16.875T10.875 15V9Q10.875 7.875 11.625 7.125T13.5 6.375H15.75L18.375 3.75V20.25L15.75 17.625H13.5Z');
            }
        }
        
        // FONCTIONS DU JEU
        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }
        
        function getRandomPiece() {
            const pieces = 'IJLOSTZ';
            const rand = pieces[Math.floor(Math.random() * pieces.length)];
            return {
                shape: PIECES[rand].shape,
                color: PIECES[rand].color,
                x: 3,
                y: 0
            };
        }
        
        function draw() {
            ctx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);
            
            // Dessiner le plateau
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(ctx, x, y, board[y][x]);
                    }
                }
            }
            
            // Dessiner la pièce actuelle
            if (piece) {
                piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            drawBlock(ctx, x + piece.x, y + piece.y, piece.color);
                        }
                    });
                });
                
                // Dessiner le ghost piece (silhouette)
                drawGhostPiece();
            }
        }
        
        function drawBlock(ctx, x, y, colorIndex) {
            ctx.fillStyle = COLORS[colorIndex];
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            // Effet de lumière
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE / 4);
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE / 4, BLOCK_SIZE);
            
            // Effet d'ombre
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x * BLOCK_SIZE + BLOCK_SIZE * 0.75, y * BLOCK_SIZE, BLOCK_SIZE / 4, BLOCK_SIZE);
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE + BLOCK_SIZE * 0.75, BLOCK_SIZE, BLOCK_SIZE / 4);
        }
        
        function drawGhostPiece() {
            const ghostY = calculateDropPosition();
            
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect((x + piece.x) * BLOCK_SIZE, (y + ghostY) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect((x + piece.x) * BLOCK_SIZE, (y + ghostY) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }
        
        function calculateDropPosition() {
            let y = piece.y;
            while (!checkCollision(piece.x, y + 1, piece.shape)) {
                y++;
            }
            return y;
        }
        
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (nextPiece) {
                const offsetX = (nextCanvas.width / BLOCK_SIZE - nextPiece.shape[0].length) / 2;
                const offsetY = (nextCanvas.height / BLOCK_SIZE - nextPiece.shape.length) / 2;
                
                nextPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            drawBlock(nextCtx, x + offsetX, y + offsetY, nextPiece.color);
                        }
                    });
                });
            }
        }
        
        function drawHoldPiece() {
            holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
            
            if (holdPiece) {
                const offsetX = (holdCanvas.width / BLOCK_SIZE - holdPiece.shape[0].length) / 2;
                const offsetY = (holdCanvas.height / BLOCK_SIZE - holdPiece.shape.length) / 2;
                
                holdPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            drawBlock(holdCtx, x + offsetX, y + offsetY, holdPiece.color);
                        }
                    });
                });
            }
        }
        
        function checkCollision(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] !== 0) {
                        const newX = x + col;
                        const newY = y + row;
                        
                        if (
                            newX < 0 || 
                            newX >= COLS || 
                            newY >= ROWS || 
                            (newY >= 0 && board[newY][newX])
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function rotate() {
            if (!piece) return;
            
            const originalShape = piece.shape;
            const rows = originalShape.length;
            const cols = originalShape[0].length;
            
            // Créer une nouvelle forme tournée
            const newShape = [];
            for (let i = 0; i < cols; i++) {
                newShape[i] = [];
                for (let j = 0; j < rows; j++) {
                    newShape[i][j] = originalShape[rows - 1 - j][i];
                }
            }
            
            // Vérifier la collision après rotation
            if (!checkCollision(piece.x, piece.y, newShape)) {
                piece.shape = newShape;
                playSound('rotate');
            }
        }
        
        function movePiece(direction) {
            if (!piece) return;
            
            if (!checkCollision(piece.x + direction, piece.y, piece.shape)) {
                piece.x += direction;
                playSound('move');
            }
        }
        
        function dropPiece() {
            if (!piece) return;
            
            if (!checkCollision(piece.x, piece.y + 1, piece.shape)) {
                piece.y++;
                lockDelayCounter = 0;
                playSound('move');
            } else {
                lockDelayCounter += dropInterval;
                
                if (lockDelayCounter > gameMode.lockDelay) {
                    lockPiece();
                }
            }
        }
        
        function hardDrop() {
            if (!piece) return;
            
            while (!checkCollision(piece.x, piece.y + 1, piece.shape)) {
                piece.y++;
                score += 2; // Bonus pour le hard drop
            }
            
            lockPiece();
            playSound('drop');
        }
        
        function lockPiece() {
            // Ajouter la pièce au plateau
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        const boardY = y + piece.y;
                        if (boardY >= 0) { // Éviter les index négatifs
                            board[boardY][x + piece.x] = piece.color;
                        }
                    }
                });
            });
            
            // Vérifier les lignes complètes
            const linesCleared = checkLines();
            if (linesCleared > 0) {
                updateScore(linesCleared);
                playSound('line');
            } else {
                playSound('lock');
            }
            
            // Réinitialiser le hold
            canHold = true;
            
            // Générer une nouvelle pièce
            piece = nextPiece;
            nextPiece = getRandomPiece();
            drawNextPiece();
            
            // Vérifier le game over
            if (checkCollision(piece.x, piece.y, piece.shape)) {
                gameOver = true;
                showGameOver();
            }
        }
        
        function checkLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(value => value !== 0)) {
                    // Supprimer la ligne
                    board.splice(y, 1);
                    // Ajouter une nouvelle ligne vide en haut
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    // Réévaluer la même position car une nouvelle ligne a été insérée
                    y++;
                }
            }
            
            lines += linesCleared;
            linesElement.textContent = lines;
            
            // Mettre à jour le niveau
            const newLevel = Math.floor(lines / 10) + 1;
            if (newLevel > level) {
                level = newLevel;
                levelElement.textContent = level;
                dropInterval = gameMode.gravity * Math.pow(gameMode.acceleration, level - 1);
                playSound('levelup');
            }
            
            return linesCleared;
        }
        
        function updateScore(linesCleared) {
            const lineScores = [0, 100, 300, 500, 800];
            score += lineScores[linesCleared] * level;
            scoreElement.textContent = score;
        }
        
        function hold() {
            if (!canHold) return;
            
            if (holdPiece) {
                const temp = piece;
                piece = holdPiece;
                holdPiece = temp;
            } else {
                holdPiece = piece;
                piece = nextPiece;
                nextPiece = getRandomPiece();
                drawNextPiece();
            }
            
            // Réinitialiser la position de la pièce
            piece.x = 3;
            piece.y = 0;
            
            canHold = false;
            drawHoldPiece();
            playSound('hold');
        }
        
        // FONCTIONS AUDIO
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(type) {
            if (!audioEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch (type) {
                case 'rotate':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // Do
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    break;
                case 'move':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime); // Do
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    break;
                case 'lock':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(196.00, audioContext.currentTime); // Sol
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    break;
                case 'line':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime); // Sol
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    break;
                case 'drop':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(123.47, audioContext.currentTime); // Si
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    break;
                case 'levelup':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // Do
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // Mi
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // Sol
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    break;
                case 'gameover':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220.00, audioContext.currentTime); // La
                    oscillator.frequency.setValueAtTime(196.00, audioContext.currentTime + 0.2); // Sol
                    oscillator.frequency.setValueAtTime(174.61, audioContext.currentTime + 0.4); // Fa
                    oscillator.frequency.setValueAtTime(146.83, audioContext.currentTime + 0.6); // Ré
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + 0.6);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                    break;
            }
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        // FONCTIONS DE GESTION DU JEU
        function startGame(mode) {
            if (typeof mode === 'string') {
                gameMode = MODES[mode];
            }
            
            // Initialiser l'audio au premier geste utilisateur
            initAudio();
            
            // Réinitialiser l'état du jeu
            board = createBoard();
            score = 0;
            lines = 0;
            level = 1;
            gameOver = false;
            paused = false;
            dropInterval = gameMode.gravity;
            
            // Générer les pièces
            piece = getRandomPiece();
            nextPiece = getRandomPiece();
            holdPiece = null;
            canHold = true;
            
            // Mettre à jour l'UI
            scoreElement.textContent = score;
            linesElement.textContent = lines;
            levelElement.textContent = level;
            
            // Dessiner les pièces suivantes et en réserve
            drawNextPiece();
            drawHoldPiece();
            
            // Cacher les overlays
            pauseOverlay.style.display = 'none';
            gameoverOverlay.style.display = 'none';
            
            // Afficher l'écran de jeu
            showScreen(gameScreen);
            
            // Démarrer la boucle de jeu
            lastTime = 0;
            requestAnimationFrame(gameLoop);
        }
        
        function togglePause() {
            paused = !paused;
            
            if (paused) {
                pauseOverlay.style.display = 'flex';
            } else {
                pauseOverlay.style.display = 'none';
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
        
        function showGameOver() {
            gameoverOverlay.style.display = 'flex';
            
            finalScoreElement.textContent = score;
            finalLinesElement.textContent = lines;
            finalLevelElement.textContent = level;
            finalModeElement.textContent = gameMode.name;
            
            playSound('gameover');
        }
        
        function saveScore() {
            const playerName = prompt('Entrez votre nom (3 caractères max):', 'AAA');
            if (playerName && playerName.length > 0) {
                const name = playerName.substring(0, 3).toUpperCase();
                const scores = JSON.parse(localStorage.getItem('blockDashScores') || '[]');
                
                scores.push({
                    name,
                    score,
                    lines,
                    level,
                    mode: gameMode.name,
                    date: new Date().toLocaleDateString()
                });
                
                // Trier par score décroissant et garder les 10 meilleurs
                scores.sort((a, b) => b.score - a.score);
                const topScores = scores.slice(0, 10);
                
                localStorage.setItem('blockDashScores', JSON.stringify(topScores));
                alert('Score enregistré!');
            }
        }
        
        function showScores() {
            const scoresList = document.getElementById('scores-list');
            scoresList.innerHTML = '';
            
            const scores = JSON.parse(localStorage.getItem('blockDashScores') || '[]');
            
            if (scores.length === 0) {
                scoresList.innerHTML = '<p style="text-align: center; padding: 20px;">Aucun score enregistré</p>';
                return;
            }
            
            scores.forEach((item, index) => {
                const scoreItem = document.createElement('div');
                scoreItem.className = 'score-item';
                
                scoreItem.innerHTML = `
                    <div>${index + 1}. ${item.name}</div>
                    <div>${item.score}</div>
                `;
                
                scoresList.appendChild(scoreItem);
            });
        }
        
        // BOUCLE PRINCIPALE DU JEU
        function gameLoop(time) {
            if (gameOver || paused) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > dropInterval || moveDownPressed) {
                dropPiece();
                dropCounter = 0;
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // INITIALISATION DU JEU
        window.addEventListener('load', () => {
            initEvents();
            // Redimensionner les canvas pour qu'ils aient la bonne taille d'affichage
            boardCanvas.width = COLS * BLOCK_SIZE;
            boardCanvas.height = ROWS * BLOCK_SIZE;
            
            // Charger l'état du mute
            const storedMute = localStorage.getItem('blockDashMute');
            if (storedMute !== null) {
                audioEnabled = storedMute !== 'true';
                updateMuteButton();
            }
        });
    </script>
</body>
</html>